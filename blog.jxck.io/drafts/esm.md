# JavaScript Module 小史

## Intro

CJS と ESM の並行運用が長いこと続いている。

歴史の要所要所でもしかしたらなんとかなったかもしれないチャンスがありながら、結局どうともならず今に至る。

今後どうなっていくのか、歴史と共に振り返りつつ、あえて筆者の主観による「タラレバ」を入れてまとめてみる。


## Module 以前

JS の仕様と実装は短期間で作られたため、諸々問題を抱えたまま世に出たのは周知の通りだ。

ブラウザで使う上では、展開されたスクリプトが全て Global を共有する方式であり、モジュールの概念がそもそもなかった。

各位が、 1 つだけ変数を Export し、その下に実装を隠す作法で運用され、割と長いことそれでなんとかなっていた。

タラレバ: 「もし最初から Module の仕組みが考えられていたら。というか、もう少しBrendan Eichに開発にかける時間的な猶予が与えられていたら。」


## Node.js と CommonJS

Ryan Dahl が Node.js の開発に取り組んだ時、さすがにサーバーサイドではモジュールの仕組みが必要だった。

そこで、 JS に足らない仕組みの提案作業をしていた CommonJS に Module の仕様があるのをみつけ、それをそのまま持ってきて実装した。

(ちなみに CommonJS は Module 意外にも Promise や File など様々な仕様をもっていた。 CJS == Module になったのは今それ以外の仕様を見ることがないから)

CommonJS にはブラウザ周りの開発者も参加していたようだが、今の TC39 ほど緻密な策定作業ではなく、それを実装して Experiment する環境もユーザも少なかった。

タラレバ: 「もし CommonJS がもう少し実装と検証のプロセスを回して、 ESM に近い仕様になっていたら。」


## NPM

Node.js の CommonJS Module (もう面倒なので CJS) の公開先として最初は複数あったが、 NPM が覇権を握っていく。

そこに Node.js のエコシステムが集約されるため、みんながそれを使うようになった。

一方で、ブラウザ向けの JS はどうするかは微妙に揺れていた。

ブラウザ用のものは別で管理しようと bower が出てきた。

どちらにも依存しないものは、グローバルに定義した変数が Node でもブラウザでも使えるように作り、 npm と bower 両方にあげようという流れが出て、 Isomorphic と呼ばれた。

が、どっちにせよ二重管理は面倒で、圧倒的な npm の重力には勝てず、 bower は忘れられていった。

タラレバ: 「とくになし」


## AMD

ブラウザで追加のモジュールを読み込む関数を考えるなら、同期の `require('name')` ではなく `require('name', callback)` になるということで、それを実現した require.js というライブラリが出た。

そこで使われる Module の仕様は Asyncronous Module Definition (AMD) と呼ばれ、これも実は CommonJS 由来だったりする。

その派生でどっちでも使える UMD なんて話もあった。

このへんは、正直よく覚えてないくらい、たいして使われなかった。

タラレバ: 「とくになし」


## browserify

最近表から姿を消したが substack という天才がいた。

彼は、書いたコードを同時にすべてのブラウザで実行して確認できる browerling というサービスを作った。

そこでは、 Node であれブラウザ向けであれ、書いたテストはなんでも実行できる tesling というテストフレームワークが使われた。

つまり「Node 向けに書かれたコードも broserling で実行できる」のだ。 `require('file')` しても `process` に触ってても何故か動く(機能はしないが止まらない)。

実は、その依存に browserify が使われていることを知った開発者は、「これ使えば Node 向けに書いたコードがブラウザでも動くじゃん」と気づいてしまった。

標準モジュールはいらないが、 CJS が動くなら npm が使える。

substack の成果のほんの一部でしかなかったはずのこの機能が、フロントエンドの開発に Bundling という概念を持ちこんでガラッと変わった。

その前から Coffee Script ~ 6to5 (現 babel) に端を発する「変換して動けばいい」の文化が徐々に浸透していたため、これが思った以上に受け入れられてしまったのだ。

ブラウザにモジュールの仕様がないという「問題」は一切解決してないが、ブラウザでも npm が使いたいしモジュール分割したいという現場の「課題」は解決してしまったのだ。

タラレバ: 「変換すればいい、でなまじ課題が解決してしまったため、問題の解決がだいぶ先送りになる。もしここで、もっと問題解決の議論が起こっていたら。」


## ESM

とはいえ、やっぱりブラウザにも標準モジュールの仕組みが欲しい。ということで、やっと ES2015 に ESM の仕様が入り、ブラウザが実装する。

CJS がそのままブラウザに来ると期待していた人もいるかもしれないが、 CJS の仕様はあまりにも微妙だし、ブラウザにも向かないので全く別のものになった。

例えば `require()` が関数であるとみなすと、実行するまで結果はわかならい。そこでパースの時点で静的に決まる構文として `import a from b` になっている。

もちろん、仕様としては ESM の方が優れていると言って良いだろう。だから、ここで「ブラウザに CJS がそのまま入ってたら」というタラレバはない。

むしろ、この流れに Node 側が全く反応しなかったこの方が残念ではある。

今の Node からは想像できないかもしれないが、昔の Node はブラウザのことを全く考えず、「なんでうちらがブラウザの都合を考えないといけないんだ」という雰囲気だった。

例えば Node の assert なんかは別にブラウザで使えても良いはずで、ちょっと書き方を変えれば当時でいう Isomorphic になったが、それを筆者が提案しても「これはブラウザ用じゃない」と門前払いだった。

(しょうがなく作った Node 互換 [assert](https://github.com/jxck/assert) は何故か広く使われ、例えば [VSCode](https://github.com/microsoft/vscode/blob/main/ThirdPartyNotices.txt#L922) にも入ってる)

タラレバ: 「あの頃の Node がもう少しブラウザや他のプラットフォームの多様性のことを考えてくれていたら。」


## Webpack

browserify の bundling の部分だけを抜き出して、使いやすくするツールが出始めた。その筆頭が Webpack だ。

単に bundle するだけでなく、それまで grunt/gulp で行っていた作業を全部巻き取って、開発環境構築の中心になっていった。

このころには  TS や JSX などのトランスパイルも普通になってきたので、 JS の開発に「ビルド」があるのは普通になった。

そのビルドの中で CJS を一個の `bundle.js` にまとめれば、ブラウザ上で普通に動く。 sourcemap が吐かれるから、デバッグもできる。

ここで ESM を使って書いたとしても、 Webpack を通せば、結局ブラウザに渡るのは `bundle.js` だ。

どっちにせよビルドプロセスは通すので、その中から bundling の部分だけ無くなっても、開発者にはあまり旨味がない。

せっかくブラウザが ESM を読めるようになっても、結局開発者は ESM の「構文」だけしか使わなかったのだ。

タラレバ: 「もし JSX/TS のようなコンパイルが必要なものが流行らず、ビルドプロセスが bundling 以外になかったら、開発者はそれを無駄と感じてもう少し動いていたかもしれない」


## Node ESM

時間は流れ、 Node のコアメンバーも入れ替わったり、 Node / Web の開発環境が変わっていくと、徐々に Node にも変化が現れる。

ついに Node でも ESM をサポートできないかと言うことで、試行錯誤が始まるのだ。

ずっと CJS でやってきた Node に EMS を入れるのは一筋縄ではいかなかったため、








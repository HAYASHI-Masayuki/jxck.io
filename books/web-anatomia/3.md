---
title: "Same Origin Policy を迂回する危険なハック"
emoji: "📝"
type: "tech"
topics: ["jsonp", "origin", "web"]
published: false
---

# SOP を迂回する危険なハック

Ajax の発見により XHR の利用が増えて以降、 CORS が定義されるまでの間は SOP のみが適用され、「Origin をまたぐリクエストはできない」という単純なルールだけがあった。複数のサービスを連携させるにはブラウザではなくサーバサイドでデータを取得し連携する必要があったが、「なんとかして SOP を迂回してクライアントで完結できないか?」という要求も絶えず、その結果 CORS が策定され普及される前に生み出された **SOP を迂回するハック** がいくつか存在する。本節では、代表的なハックとその危険性を解説する。

先に言っておくと、 **SOP を迂回するハックはなんであれ推奨されない** ため、 CORS を正しく用いた安全で正しい設計を心がけるべきである。


## JSONP による迂回

`<script>` タグは JS を取得するために GET を発生するが、異なる Origin を記述しても CORS の対象にはならない。これを利用して SOP を迂回する方法が JSONP だ。実際に JSONP を用いて、 CORS を使わずに Intra の情報を SNS で取得してみよう。


### \<scirpt\>によるデータ連携

まず、 SNS に次のような HTML を設置する。


```html
<!-- SNS 上で Intra の JS を読み込む -->
<script src="https://intra.example/script.js"></script>
```

この `<script>` から発生するリクエストは次のようになり、 Preflight はもちろん Origin ヘッダも付与されない。


```http
GET /script.js HTTP/1.1
Host: intra.example
```

レスポンスにも、 `Access-Control-Allow-Origin` ヘッダは必要ない。


```http
HTTP/1.1 200 OK
Content-Type: application/javascript

console.log("hello")
```

Intra から返った JS は普通に実行される。これを応用すると、次のようなことができる。

SNS が Intra の情報を取得したいと思った場合、 Intra はその情報を次のような JS で提供する。


```js
// data.js
const data = {
  username: "Jxck",
  email: "jxck@mail.example"
}
```

SNS は、これを次のように利用する。


```html
<script src="https://intra.example/data.js"></script>
<script>
  console.log(data) // 表示可能
</script>
```

するとブラウザ上では 2 つの JS は同じスコープで評価され、取得したデータが表示できる。


```js
// 2つのJSは結合したように実行される

// https://sns.example/data.js
const data = {
  username: "Jxck",
  email: "jxck@mail.example"
}

// https://intra.example/app.js
console.log(data) // 表示可能
```

これによって、 SNS の JS は別 Origin である Intra が提供するデータを取得できた。


### Callback 関数の指定

しかし、このままでは、検索クエリが決まってから動的に読み込むといったことができない。そこで、変数名を共有するのではなく、コールバック関数名を共有するようにする。

例として、コールバック関数を `callback` という名前にしたら、 Intra はデータを `callback` という関数の引数として渡すように囲んだ `data.js` を提供する。


```js
callback({
  username: "Jxck",
  email: "jxck@mail.example"
})
```

SNS では、データを受け取る `callback()` 関数を定義し、この `<script>` タグを動的に生成し追加すれば、任意のタイミングで任意のデータを任意の Origin から取得できるのだ。


```html
<script>
  function callback(data) {
    // データがこの関数に渡ってくる
    console.log(data)
  }
</script>

<script src="https://intra.example/data.js"></script>
<!-- これが関数を実行する -->
```

もし複数回呼び出す場合、コールバック関数名が決め打ちだと困るため、コールバック関数名は呼び出し側がクエリパラメータで指定できる API が多い。


```html
<script>
  // コールバック関数を fn としたい場合
  function fn(data) {
    // データがこの関数に渡ってくる
    console.log(data)
  }
</script>

<!-- クエリパラメータにコールバック関数名を fn として指定する -->
<script src="https://intra.example/data.js?callback=fn"></script>
<!-- これが関数を実行する -->
```

この場合サーバからは以下のような JS が返る。


```js
fn({
  username: "Jxck",
  email: "jxck@mail.example"
})
```

このように、取得したいデータを関数実行で囲んで(Padding)、 JS として返すことで Origin をまたいだデータのやりとりを CORS なしで行う手法が JSONP(JSON Padding)だ。 JSONP は実装が手軽だったため、 CORS が普及する以前に広まった。

しかし、任意の Origin から取得できるということは、攻撃サイトからも同じ方法で情報が取得できることを意味する。 Cookie で制限しているつもりでも、リクエストには Cookie が自動で付与され、防御にはならない。実際に、サービス内で個人情報を JSONP で取得していた大手 Web メールサービスで、その情報が抜き取られる脆弱性が報告されたこともある。

Origin をまたいだデータを提供する場合は、 `Origin` ヘッダをもとに `Access-Control-Allow-Origin` ヘッダを正しく返すことで取得元を制限するように、 CORS をきちんと設定して使うべきだ。

主要なブラウザが CORS に対応している今、 JSONP は基本的に採用するべきものではない。


## document.domain による迂回

:::message alert
TODO: もう少し広げる
:::

SOP の実体は、 **ある Origin のコンテンツからは、同じ(Same)Origin のコンテンツにしかアクセスできない** という制限のことだった。これは `fetch()` のようなネットワークアクセスだけではなく、 `<iframe>` などでも同じように適用される。

例えば、 `a.intra.example` に `b.intra.example` を `<iframe>` で埋め込んだ場合、 Origin が違うので iframe 間の `Document` の参照はできない。しかし、 `<iframe>` の場合は両者が次のように共通する親ドメインの `intra.example` に `document.domain` を変えると、両者は同じ Origin とみなされ、双方にアクセスできる。


```js
document.domain = "intra.example"
```

これは古くから、 SOP を迂回する手段の一つとして使われてきた。そのため、ブラウザにおいては Origin を考えるときに、 `document.domain` の存在を無視できない。

その結果、 Origin の定義は、主にプロトコルを策定している IETF と、ブラウザ API を策定している WHATWG それぞれにドキュメントがあり、双方で異なる。

- [RFC 6454 The Web Origin Concept](https://tools.ietf.org/html/rfc6454#section-4)
- [HTML Standard](https://html.spec.whatwg.org/multipage/origin.html)

RFC 6454 での Origin の定義は本稿前半で解説したように Scheme 、 Host 、 Port の 3 つだが、 WHATWG では 4 つ目として Domain という要素が追加されている。 Domain は、 `document.domain` が Origin に与える影響を明確にするために追加されたものだ。

`document.domain` を変えることで SOP を迂回する実装は、 XSS などの脆弱性があったときに問題になり得る。例えば、 SNS が社員ごとにサブドメインを分ける作りになっていたとする。

- alice.sns.example
- eve.sns.example

もし、 SNS に XSS の脆弱性があり、両方の `document.domain` を `sns.example` にできてしまうと、例えば Eve は Alice の情報を `<iframe>` 経由で読める可能性がある。

現在では CORS を用いた連携や `<iframe>` 間の postMessage などの代替手段があるため、 `document.domain` の積極的な採用は避ける方が良いだろう。[^1]

[^1]: 最近では iframe sandbox や Feature Policy といった機能により、 `document.domain` の書き換え自体を制限していく動きもある。)。


## WebSocket と Origin


## Service Worker と Opaque Response


## CORS を迂回するバグの重大さ


# まとめ

Web の重要なセキュリティモデルである Origin/SOP/CORS の基本について解説しました。

誌面に収まらなかった「ServiceWorker や WebSocket での Origin」「Origin と範囲の違う Cookie の課題」「Cross-Origin Information Leaks」などについては、いずれ解説できればと思う。
